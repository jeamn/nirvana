import{q as e,g as d,L as o}from"./common-874b6af4.js";const a='{"title":"【深入浅出 Vue.js】VNode","frontmatter":{"date":"2022-04-06T00:00:00.000Z","title":"【深入浅出 Vue.js】VNode","tags":["Vue"]},"headers":[{"level":2,"title":"一、什么是 VNode","slug":"一、什么是-vnode"},{"level":2,"title":"二、VNode 的作用","slug":"二、vnode-的作用"},{"level":2,"title":"三、VNode 的类型","slug":"三、vnode-的类型"}],"relativePath":"docs/vue/book/srqc-5.md","lastUpdated":1673514417696.2046}';var l={};const n=[o('<h2 id="一、什么是-vnode"><a class="header-anchor" href="#一、什么是-vnode" aria-hidden="true">#</a> 一、什么是 VNode</h2><p>在 Vue.js 中存在一个 VNode 类，使用它可以实例化不同的 vnode 实例，而不同的 vnode 实例各自表示不同类型的 DOM 元素（如元素节点、文本节点、注释节点）</p><h2 id="二、vnode-的作用"><a class="header-anchor" href="#二、vnode-的作用" aria-hidden="true">#</a> 二、VNode 的作用</h2><p>每次渲染视图时都是先创建 vnode，然后使用它创建真实 DOM 插入到页面中，所以可以将上一次渲染视图时所创建的 vnode 缓存起来，之后需要重新渲染视图时，将新创建的 vnode 和上一次缓存的 vnode 进行对比，找出不一样的地方进行修改。</p><p>Vue.js 目前采用中等粒度，变化只能通知到组件级别，那么只要组件使用的众多状态中有一个发生了改变，那么这个组件就要重新渲染。这显然是性能浪费，所以 vnode 就是来让避免重新渲染整个组件。</p><h2 id="三、vnode-的类型"><a class="header-anchor" href="#三、vnode-的类型" aria-hidden="true">#</a> 三、VNode 的类型</h2><ul><li>注释节点</li><li>文本节点</li><li>元素节点</li><li>组件节点</li><li>函数式组件</li><li>克隆节点</li></ul>',7)];l.render=function(o,a,l,i,t,r){return e(),d("div",null,n)};export{a as __pageData,l as default};
