import{q as t,g as l,L as e}from"./common-874b6af4.js";const r='{"title":"【JavaScript】继承","frontmatter":{"date":"2023-01-11T00:00:00.000Z","title":"【JavaScript】继承","tags":["JavaScript"]},"headers":[{"level":2,"title":"原型链继承","slug":"原型链继承"},{"level":2,"title":"借用构造函数","slug":"借用构造函数"},{"level":2,"title":"组合继承","slug":"组合继承"},{"level":2,"title":"寄生组合式继承","slug":"寄生组合式继承"}],"relativePath":"docs/javascript/inherit.md","lastUpdated":1674123919338.2434}';var a={};const i=[e('<h2 id="原型链继承"><a class="header-anchor" href="#原型链继承" aria-hidden="true">#</a> <strong>原型链继承</strong></h2><ul><li>每个构造函数都有一个prototype属性，即该构造函数的原型。</li><li>每个对象都有一个__proto__属性，该属性指向其构造函数的原型。</li><li>这种对象之间的引用关系，会形成一条关系链，叫它“原型链”。所以原型链可以实现最简单那的继承。</li><li>如果我们将一个构造函数的原型指向了另外一个构造函数的实例，那么该构造函数的原型的constructor指针就会由原来的指向构造函数本身转而指向一个新的对象。</li></ul><blockquote><p>原型链继承有缺陷：当原型链中包含引用类型的原型时，该引用类型值会被所有实例共享；在创建子类型的实例时，不能向父类型的构造函数中传递参数，只能在原型改变时去传这些参数。</p></blockquote><h2 id="借用构造函数"><a class="header-anchor" href="#借用构造函数" aria-hidden="true">#</a> <strong>借用构造函数</strong></h2><ul><li>在子类型构造函数的内部调用父类的构造函数，并传递子类型构造函数的参数（Animal.call(this, …arguments)）。</li></ul><blockquote><p>缺点是，“借用构造函数继承”只能继承父类的实例属性和方法，不能继承静态属性和方法。</p></blockquote><h2 id="组合继承"><a class="header-anchor" href="#组合继承" aria-hidden="true">#</a> <strong>组合继承</strong></h2><ul><li>可以将原型链继承和借用构造函数结合起来，各取所长。</li><li>通过原型链的方式实现对原型属性和方法的继承，通过借用构造函数实现对实例属性和方法的继承。</li></ul><blockquote><p>缺点是，会调用父类方法两次，先直接调用实现实例属性的继承，再通过构造函数调用实现父类属性的继承。</p></blockquote><h2 id="寄生组合式继承"><a class="header-anchor" href="#寄生组合式继承" aria-hidden="true">#</a> <strong>寄生组合式继承</strong></h2><ul><li>调用两次父类函数会有一定消耗，所以就有了寄生组合式继承，主要结合了寄生式继承和组合继承的优点。</li><li>通过寄生式封装函数设置父类的prorotype为子类prototype的原型来继承父类的prototype声明的属性和方法，而不再是new父类去实现继承。</li><li>过程其实是通过将父类的原型对象赋给一个临时函数的原型对象，再设置子类的prototype原型为临时函数的实例，以及指定子类的原型的构造函数为子类自身。</li></ul>',11)];a.render=function(e,r,a,o,s,n){return t(),l("div",null,i)};export{r as __pageData,a as default};
