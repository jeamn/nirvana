<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>
      【JavaScript】ES6笔记之Iterator遍历器 | Nirvana
    </title>
    <meta name="description" content="A VitePress site">
    <link rel="stylesheet" href="/nirvana/_assets/style.b16d0605.css">
    <link rel="modulepreload" href="/nirvana/_assets/common-874b6af4.js">
    <link rel="modulepreload" href="/nirvana/_assets/docs_javascript_es6-Iterator.md.942ac03c.lean.js">
    <link rel="modulepreload" href="/nirvana/_assets/app.963d3ba1.js">
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <meta name="keywords" content="Jeamn">
    <link rel="icon" href="/favicon.ico">
    <link rel="stylesheet" href="https://lib.baomitu.com/gitalk/1.7.0/gitalk.min.css">
    <script src="https://lib.baomitu.com/gitalk/1.7.0/gitalk.min.js"></script>
    <script src="https://lib.baomitu.com/axios/0.21.1/axios.js"></script>
    
  </head>
  <body>
    <div id="app"><!--[--><div id="containerColor" class="no-sidebar theme" data-v-4a5ae416><header class="navbar" data-v-4a5ae416><!--[--><a class="title" aria-label="Nirvana, back to home" href="/nirvana/"><img class="logo" src="/nirvana/favicon.ico" alt="logo"><span>Nirvana</span></a><div class="flex-grow"></div><nav class="nav-links hide-mobile"><!--[--><!--[--><div class="nav-item"><a class="nav-link" href="/nirvana/index.html" target="" rel="">🏠 首页 <!-- <OutboundLink v-if="isExternalLink" /> --></a></div><!--]--><!--[--><div class="nav-item"><a class="nav-link" href="/nirvana/more/docs.html" target="" rel="">📅 归档 <!-- <OutboundLink v-if="isExternalLink" /> --></a></div><!--]--><!--[--><div class="nav-item"><a class="nav-link" href="/nirvana/more/tags.html" target="" rel="">📂 分类 <!-- <OutboundLink v-if="isExternalLink" /> --></a></div><!--]--><!--]--><!----><!----></nav><!--[--><!--]--><!--]--><div class="sidebar-button" data-v-4a5ae416><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div></header><aside class="" data-v-4a5ae416><!--[--><nav class="nav-links show-mobile"><!--[--><!--[--><div class="nav-item"><a class="nav-link" href="/nirvana/index.html" target="" rel="">🏠 首页 <!-- <OutboundLink v-if="isExternalLink" /> --></a></div><!--]--><!--[--><div class="nav-item"><a class="nav-link" href="/nirvana/more/docs.html" target="" rel="">📅 归档 <!-- <OutboundLink v-if="isExternalLink" /> --></a></div><!--]--><!--[--><div class="nav-item"><a class="nav-link" href="/nirvana/more/tags.html" target="" rel="">📂 分类 <!-- <OutboundLink v-if="isExternalLink" /> --></a></div><!--]--><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar"><!--[--><!--]--></ul><!--[--><!--]--><!--]--></aside><!----><!-- TODO: make this button accessible --><div class="sidebar-mask" data-v-4a5ae416></div><main data-v-4a5ae416><!--[--><div class="content"><!--[--><!--]--><div class="md-header"><div class="md-title">【JavaScript】ES6笔记之Iterator遍历器</div><span id="jinrishici-sentence">正在加载今日诗词....</span><div class="md-date">2017-08-18T00:00:00.000Z</div></div><ul class="catalog"><!--[--><li class="catalog-item"><!----><a class="level level-3" href="#_1-初识-iterator">1.初识 Iterator</a></li><li class="catalog-item"><!----><a class="level level-3" href="#_2-默认iterator接口">2.默认Iterator接口</a></li><li class="catalog-item"><!----><a class="level level-3" href="#_3-调用iterator接口的场合">3.调用Iterator接口的场合</a></li><li class="catalog-item"><!----><a class="level level-3" href="#_4-字符串的iterator接口">4.字符串的Iterator接口</a></li><li class="catalog-item"><!----><a class="level level-3" href="#_5-iterator和generator函数">5.iterator和Generator函数</a></li><li class="catalog-item"><!----><a class="level level-3" href="#_6-遍历器对象的return-和throw">6.遍历器对象的return( )和throw( )</a></li><li class="catalog-item"><!----><a class="level level-3" href="#_7-for-of循环">7.for...of循环</a></li><!--]--></ul><div><h3 id="_1-初识-iterator"><a class="header-anchor" href="#_1-初识-iterator" aria-hidden="true">#</a> 1.初识 Iterator</h3><p><strong>概念：</strong> 遍历器是一种统一的的接口机制，来处理所有不同的数据结构（数组，对象，Map，Set），只要数据结构有部署Iterator接口，就可以完成遍历操作。</p><p><strong>作用：</strong> 提供统一访问接口，使得数据结构成员按某种次序排列，供新的遍历命令for...of使用。 <!--more--></p><p><strong>过程：</strong> 创建一个指针对象，指向当前数据结构的起始位置。第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员，以此类推，直到指向结束。每一次调用next，都返回包含value和done的对象，value表示当前成员的值，done表示是否结束。</p><p>对于遍历器对象来说，done：false和value：undefined属性可以省略。</p><h3 id="_2-默认iterator接口"><a class="header-anchor" href="#_2-默认iterator接口" aria-hidden="true">#</a> 2.默认Iterator接口</h3><p>当使用for...of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。</p><p>只要部署了Iterator接口，或者，一个数据结构只要有Symbol.iterator属性，就称该数据结构是可遍历的。 默认的Iterator接口部署在数据结构的Symbol.iterator属性，其本身是一个函数，就是当前数据结构默认的遍历器生成函数，执行之后会返回一个遍历器。</p><div class="language-js"><pre><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token punctuation">{</span>
			<span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token keyword">return</span> <span class="token punctuation">{</span>
					<span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
					<span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>解析：对象obj中有Symbol.iterator属性，所以它是可遍历的。执行这个属性，会返回一个遍历器对象。改对象的根本特征就是由next方法，每次调用next方法，都会返回一个代表当前成员的信息对象，具有两个属性。</p></blockquote><p>凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口，调用该接口，就会返回一个遍历器对象。</p><p>ES6的数组结构原生部署了Symbol.iterator属性，数组的遍历器接口部署在该属性上面，调用这个属性，就得到遍历器对象。而对象没有，因为不确定先遍历哪个对象。</p><p>原生具有Iterator接口的数据结构有以下：Array、Map、Set、String、TypedArray、函数的arguments对象、NodeList对象。</p><p>对于原生部署Iterator接口的数据结构，不用自己写遍历生成函数，for...of循环会自动遍历，其他数据结构的Iterator接口要在自己的Symbol.iterator属性上面部署，才会被for...of循环遍历。原因是：遍历器的本质是一种线性处理，部署遍历器接口，就等于部署一种线性变换。</p><p>给类似数组的对象部署Iterator接口，可以Stmbol.iterator方法直接引用数组的Itorator接口。</p><p>Symbol.iterator方法对应的一定要是遍历器生成函数，不然解析引擎会报错。</p><p>有遍历器接口后，数据结构就可以用for...of和 while 循环遍历。</p><h3 id="_3-调用iterator接口的场合"><a class="header-anchor" href="#_3-调用iterator接口的场合" aria-hidden="true">#</a> 3.调用Iterator接口的场合</h3><p>Iterator接口即Synbol.iterator方法，默认调用的场合有以下几种：</p><p>（1）解构赋值：对数组和Set结构进行解构赋值时，会默认调用更该方法。</p><p>（2）扩展运算符 ...</p><p>（3）yield*</p><p>（4）Promise.race( )、Promise.all( )</p><h3 id="_4-字符串的iterator接口"><a class="header-anchor" href="#_4-字符串的iterator接口" aria-hidden="true">#</a> 4.字符串的Iterator接口</h3><p>字符串是类数组数据结构，也具有原生的Iterator接口。</p><h3 id="_5-iterator和generator函数"><a class="header-anchor" href="#_5-iterator和generator函数" aria-hidden="true">#</a> 5.iterator和Generator函数</h3><p>两者结合是Symbol.iterator方法的最简单实现。</p><h3 id="_6-遍历器对象的return-和throw"><a class="header-anchor" href="#_6-遍历器对象的return-和throw" aria-hidden="true">#</a> 6.遍历器对象的return( )和throw( )</h3><p>遍历器必须部署的方法是next（），return（）和throw（）是可选部署。</p><p>return（）使用：如果for...of循环提前退出（break或者continue语句），就会调用return方法。或者一个对象在遍历完成前，需要清理或释放资源。</p><p>return方法必须返回一个对象。throw方法主要配合generator函数使用。</p><h3 id="_7-for-of循环"><a class="header-anchor" href="#_7-for-of循环" aria-hidden="true">#</a> 7.for...of循环</h3><p>循环内部调用的是Symbol.iterator方法。</p><p>for...in循环获取键名，for...of循环获取键值。</p><p>for...of可以借助数组实例的entries方法和keys方法来获取数组的索引。</p><p>Set和Map遍历顺序是按照成员添加进数据结构的顺序，Set返回一个值，Map返回一个数组。</p><p>计算生成的数据结构： ES6的数组，Set，Map都部署了三个方法,都返回一个遍历器</p><p>对象： <strong>entries( ):</strong> 用来遍历【键名，键值】组成的数组。Map结构的Iterator接口默认就是调用该方法。 <strong>keys( ):</strong> 遍历所有键名。 **values( )😗*遍历所有键值。</p><p>类数组对象： 并不是所有类数组对象都有Iterator接口，解决办法就是使用Array.from方法将其转化为数组。</p><p>对象： 普通对象不能直接使用for...of，必须部署iterator接口。</p><p>解决方法：使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。</p><p>或者使用Generator函数将对象重新包装一下。</p><ul><li>与其他遍历法比较：</li></ul><p><em>数组为例：</em></p><p>原始方法是for（比较麻烦）-----&gt; foreach方法（无法中途跳出foreach）-----&gt;for in（数组的键名是数字，但是for...in循环是以字符串‘1’，‘2’。for...in不仅遍历数字键名，还有其他键，以及原型链上的键。某些情况遍历的时候无顺序。所以只适合遍历对象）。</p><hr><p>参考书籍 <a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener noreferrer">阮一峰的ES6标准入门</a></p></div><div class="links-wrapper"><div class="prev-link"><!----></div><div class="next-link"><!----></div></div><div><p class="platform"> Copyright © 2022-2023 <a href="https://github.com/jeamn">@Jeamn</a></p></div><!--[--><!--]--></div><!-- 只想点击背景才关闭 请使用 .self 修饰符 --><div style="display:none;" class="imgBox"><img src=""></div><!--]--></main><div class="theme-select" data-v-4a5ae416><ul data-v-4a5ae416><li class="active" data-v-4a5ae416>☀️</li><li class="" data-v-4a5ae416>🌑</li></ul></div></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"README.md\":\"74ba73cf\",\"index.md\":\"c2842757\",\"more_Friendship.md\":\"2ddbc272\",\"more_docs.md\":\"ac4de4a9\",\"more_index.md\":\"2f258ce2\",\"more_tags.md\":\"9c361e7d\",\"docs_algorithm_monotonic-stack.md\":\"06425485\",\"docs_browser_cookie.md\":\"8cbcb41a\",\"docs_browser_rendering.md\":\"8f638c6b\",\"docs_javascript_anti-shaking-and-throttling.md\":\"9af40163\",\"docs_javascript_bind.md\":\"0e4d9cea\",\"docs_javascript_closure.md\":\"9c603236\",\"docs_javascript_es6-Iterator.md\":\"942ac03c\",\"docs_javascript_es6-Promise.md\":\"56c7c057\",\"docs_javascript_es6-module.md\":\"0b7596e3\",\"docs_javascript_event-loop.md\":\"9969f462\",\"docs_javascript_inherit.md\":\"7889c76a\",\"docs_javascript_scope.md\":\"15bb219e\",\"docs_node_realize-require.md\":\"3830c2f9\",\"docs_vue_interview.md\":\"005b29bf\",\"docs_vue_vue-array-update.md\":\"041757dc\",\"docs_vue_vue-bind.md\":\"6fc818cf\",\"docs_vue_book_srqc-1.md\":\"e66ab639\",\"docs_vue_book_srqc-10.md\":\"b56c32c7\",\"docs_vue_book_srqc-2.md\":\"4e783021\",\"docs_vue_book_srqc-3.md\":\"028c7b9d\",\"docs_vue_book_srqc-4.md\":\"74007c18\",\"docs_vue_book_srqc-5.md\":\"d3152f32\",\"docs_vue_book_srqc-6.md\":\"f53289b5\",\"docs_vue_book_srqc-7.md\":\"b6d0a962\",\"docs_vue_book_srqc-8.md\":\"95cb9979\",\"docs_vue_book_srqc-9.md\":\"2a093e51\"}")</script>
    <script type="module" async src="/nirvana/_assets/app.963d3ba1.js"></script>
  </body>
</html>