---
date: 2017-08-09
title: 【JavaScript】防抖动和节流阀
tags:
  - JavaScript
---
### 一、场景
JavaScript 是事件驱动，事件发生的速度不能控制，但可以通过函数来控制何时和如何激活正确的响应。***debounce*** 和 ***throttle*** 都是用来控制某个函数在一定时间内执行次数的技巧。
<!--more-->
### 二、防抖动Debounce
电子学领域中意味着把采集到的所有波动信号当成一个。
在 JS 中，防抖动可以把多个连续快速发生的事件的调用合并成一次执行。

* 举个 🌰 ：

 > *keydown* 和 *keyup* 事件，如果按住一个键不放，则 *keydown* 事件会被连续触发，这就是上文说的连续快速发生的事件。

  
我们明显不想连续输入很多次吧？所以用 ***Debounce*** 来防抖动，让连续快速触发的事件只执行一次。

那么 ***Debounce*** 事件什么时候才会触发相应功能呢？

答案是：**直到事件快速执行停止后**。


而 *keyup* 事件只有在按键释放时才会触发，当释放按键时，也就是结束了 *keydown* 事件的连续快速触发，这个时候，***Debounce*** 防抖动就会触发。所以，称 *keyup* 是去抖动输入。

* 这里有一个需要注意的地方：

    >如果事件触发的时间间隔稍微长一点的话，那么是触发不了 ***Debounce*** 的。

这个怎么理解呢？

意思是说，我们把刚刚长按一个键的操作换成了连续快速地按一个键，那么是不触发 ***Debounce*** 的。

***Debounce*** 的原理：
当事件发生时，我们不会立即激活回调，而是等待一定时间并检查相同的事件是否再次触发。如果再次触发，则重置定时器，并再次等待。如果在等待期间没有发生相同的事件，就立即激活回调。

* 这里举两个 🌰 ：
    
    >1.网页窗口调整大小，只关心用户停止调整大小后的最终值，而不关心在调整过程中大小的变化。
     
    >2.基于AJAX请求的自动完成功能，通过 *keypress* 触发，文本框内直到用户输完，才验证输入的正确性以及显示错误信息，用户输一半是不会提示的。
    
那么为什么 ***Debounce*** 不立即激活回调呢？这正是它出现的原因。

如果立即激活回调的话，就变成 ***Debounce*** 的前缘  immediate 了。immediate 是 ***Debounce*** 的精确版本。它在事件触发时立即激活回调，然后等待后续事件在一定时间内触发。
它需要一个状态变量来检查我们是否应该激活我们的回调。
用一句话概括就是，直到两次快速调用之间的停顿结束，事件才会再次触发。

### 三、节流阀 Throtting

在浏览器中，帧速率为 *60fps* 是流畅，说明我们有 16.7ms（1000/60）的时间用于响应一些事件所需要的更新。

*mousemove* 事件每秒可以超过60次，如果回调时间需要超过 16.7ms 的话，就开始乱了。

解决的方法：

***Throtte*** 允许限制激活响应的数量，可以限制每秒回调的数量，即在激活下一个回调之前要等待多久时间。

***Throttle*** 只允许一个函数在 X 毫秒内执行一次，而且至少执行一次。

* 举个 🌰 ：   

    >无限向下滚动的页面希望滚动到接近底部的时候自动加载隐藏的数据，可以通过发 AJAX 请求获取。

    而 ***Debounce*** ，只有等停止滚动了才会加载，这比较缺乏用户体验。
    
### 四、requestAnimationFrame
请求动画帧，这是 H5 一个请求动画的API。

我们先了解一些常见的动画实现方法：
JS 可以通过定时器 *setTimeout* 来实现，CSS3 用 *transition* 和 *animation* 实现， H5 中的 *canvas* 也能实现。

那 ***requestAnimationFrame*** （下称 **rAF**）有什么优势呢？
我们知道， *setTimeout* 是通过设置一个时间间隔来不断改变图像位置以达到动画的效果。但是它的执行事件并不是确定的。因为 *setTimeout* 是异步执行的，只有当主线程上的任务执行完成后，才会检查该是否有异步任务需要执行。所以其实它执行的事件要晚一些。这可能造成动画帧卡顿。

接下来我们开始介绍 **rAF** :

**rAF** 是浏览器用于定时循环操作的一个接口，按帧对网页进行重绘。目的是让各种动画效果有一个统一的刷新机制。
代码中使用这个 API ，就是告诉浏览器希望执行一个动画，让浏览器在下一个动画安排一次网页重绘。
它的原理是利用了显示器的刷新机制（每秒60次）。一旦页面不处于浏览器的当前标签，就自动停止刷新，节省 CPU 能耗。
与 *setTimeout* 相比， **rAF** 最大的优势就是由系统来决定回调函数的执行时机。

所以它的优点是什么呢？

- CPU 节能：动画保持 60 fps ，在页面未激活时停止渲染。
- 函数节流：在高频率事件（resize，scroll）中，防止在一个屏幕刷新间隔内发生多次函数执行， **rAF** 可保证在每个刷新间隔内只执行一次。

然而它的缺点是什么呢？

- 动画的开始要开发者控制，不像 *Debounce* 和 *throttle* 由函数内部处理。
- node.js 不支持，无法再服务器端用于文件系统文件。
- 主线程繁忙时效果不好。

接着看看它的代码实现：

```js
var progress = 0;
//回调函数
function render() {
    progress += 1; //修改图像的位置
 
    if (progress < 100) {
           //在动画没有结束前，递归渲染
           window.requestAnimationFrame(render);
    }
}
 
//第一帧渲染
window.requestAnimationFrame(render);

```

使用方法就是：传递一个参数到回调函数，它是一个以毫秒为单位的高分辨率时间戳。这个回调函数会在浏览器重绘之前调用。
因此，可以用 **rAF** 作为 *setTimeout* 的替代方法，来实现函数节流。

### 五、总结
**Debounce ：** 把触发非常频繁的事件（如按键）合并成一次执行。

**Throttle ：** 保证 X 毫秒恒定的执行次数（如每 200 毫秒检查下滚动位置，并触发 CSS 动画）。

**requestAnimationFrame ：** 保证在每个刷新间隔内函数只被执行一次，实现节流节能。

如果 JavaScript 方法需要绘制或直接改变属性，涉及到重新计算元素位置的，就用 **rAF** 。
如果涉及 AJAX 请求，添加或移除 class 的，就用 **.debounce** 或者 **.throttle** ，因为这样可以设置更低的执行频率。

-----------

***借鉴的文档：***

[阮一峰老师的 JavaScript 标准参考教程](http://javascript.ruanyifeng.com/htmlapi/requestanimationframe.html)

[ DAVID CORBACHO 的文章](https://css-tricks.com/debouncing-throttling-explained-examples/)
















